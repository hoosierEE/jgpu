#+PROPERTY: header-args:J :exports both :output results
#+PROPERTY: header-args:C :main no :mkdirp t
#+SETUPFILE: ~/org/blog.org
* call a (simple) dynamic library from J
** a C library
#+begin_src C :tangle src/foobar.c
void foo(int *x){x[0] += 3;}
int bar(int *a){return a[1];}
int baz(int *a, int b){return a[b];}
#+end_src

** build as a dynamic library
Note: using MacOS in this example, so file extension is ~.dylib~.
#+begin_src bash :results none
mkdir -p src/lib
gcc -c src/foobar.c -o src/lib/foobar.o
gcc -dynamiclib src/lib/foobar.o -o src/lib/libfoobar.dylib
#+end_src

** call from J
The ~cd~ function returns a list of boxes.
The first item is the return value from the foreign function call.
The remaining values are the arguments which were given to ~cd~.
This seemed pointless to me at first, until I realized that C can't return arrays.
Instead, you can pass a pointer to an array, modify the array inside the function, and examine the array after the function returns.

This "modify by reference" behavior is demonstrated by this first example:
#+begin_src J
a =: <0 1 2
'./src/lib/libfoobar.dylib foo n *i' cd a
#+end_src

#+RESULTS:
: ┌─┬─────┐
: │0│3 1 2│
: └─┴─────┘

Interestingly, the J value ~a~ was not actually changed, indicating that J has a second copy.
Perhaps this is what [[https://www.jsoftware.com/help/jforc/calling_external_programs.htm][JfC]] means by "adequate only for simple functions".
#+begin_src J
a =: <0 1 2
result =: './src/lib/libfoobar.dylib foo n *i' cd a
(a);<result
#+end_src

#+RESULTS:
: ┌───────┬─────────┐
: │┌─────┐│┌─┬─────┐│
: ││0 1 2│││0│3 1 2││
: │└─────┘│└─┴─────┘│
: └───────┴─────────┘

In the next example, the return value is a[1]:
#+begin_src J
'./src/lib/libfoobar.dylib bar i *i' cd <1 2 3
#+end_src

#+RESULTS:
: ┌─┬─────┐
: │2│1 2 3│
: └─┴─────┘

Pass multiple arguments to ~cd~ as a list of boxes:
#+begin_src  J
'./src/lib/libfoobar.dylib baz i *i i' cd 1 2 3;2
#+end_src

#+RESULTS:
: ┌─┬─────┬─┐
: │3│1 2 3│2│
: └─┴─────┴─┘

* printing
#+begin_src C :tangle src/prnt.c
#include <stdio.h>
void print(int* x, int len){printf("( ");for(int i=0;i<len;++i){printf("%d ", x[i]);}printf(")\n");}
#+end_src

#+begin_src bash :results none
gcc -c src/prnt.c -o src/lib/prnt.o
gcc -dynamiclib src/lib/prnt.o -o src/lib/libprnt.dylib
#+end_src

The first line is printed by C, the remaining lines are the return value of the foreign function.
#+begin_src J
'./src/lib/libprnt.dylib print n *i i' cd a;#a =: 2 4 6 8 10
#+end_src

#+RESULTS:
: ( 2 4 6 8 10 )
: ┌─┬──────────┬─┐
: │0│2 4 6 8 10│5│
: └─┴──────────┴─┘
* struct
#+begin_src C :tangle src/s.c
struct stuff {double a[2]; int i;};
void fn(struct stuff *x) {x->a[x->i] += 100;}
#+end_src

#+begin_src bash :results none
gcc -c src/s.c -o src/lib/s.o
gcc -dynamiclib src/lib/s.o  -o src/lib/libs.dylib
#+end_src

#+begin_src J
'./src/lib/libs.dylib fn '
#+end_src
